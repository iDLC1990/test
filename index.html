<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LCDR LIVE DATA 2025 - Диагонали</title>
  <style>
    body {
      background-color: #000;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 10%;
      background-color: #111;
      flex-wrap: wrap;
    }
    .header h1 {
      margin: 0;
      color: #008080;
      font-size: 24px;
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }
    .date-info {
      color: #008080;
      font-size: 20px;
    }
    select {
      padding: 6px 10px;
      font-size: 16px;
      border-radius: 5px;
      border: none;
    }
    #stats-container {
      width: 90%;
      margin: 24px auto;
      overflow-x: auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: #222;
      color: #fff;
    }
    th, td {
      border: 1px solid #555;
      padding: 8px 10px;
      text-align: center;
      font-size: 14px;
      white-space: nowrap;
    }
    th {
      background-color: #008080;
      font-weight: bold;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    td:first-child {
      background-color: #111;
      font-weight: bold;
      text-align: left;
      position: sticky;
      left: 0;
      z-index: 1;
    }
    th.total-col, td.total-col {
      background-color: #005050;
      font-weight: bold;
      cursor: pointer;
    }
    tfoot td {
      background-color: #005050;
      font-weight: bold;
    }
    button.toggle-btn {
      background: none;
      border: none;
      color: #fff;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      padding: 0;
      margin: 0;
    }
    button.toggle-btn:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>LCDR LIVE DATA 2025 - Диагонали</h1>
    <div class="controls">
      <label for="month-select" class="date-info">Wybierz miesiąc:</label>
      <select id="month-select"></select>
    </div>
  </div>

  <div id="stats-container"></div>

  <script>
    const apiKey = 'AIzaSyCP7tzYiGwIZ6cymLAlv_9QgPIEshnRgqI';
    const sheetId = '10W03bvKlVFlIUcxsHkzP_v_13gtnYRBmnrrO0ujB1bU';
    const sheetURL = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/`;

    const diagonalMap = {
      '860': 86, '850': 85, '750': 75, '700': 70, '650': 65, '580': 58, '575': 58,
      '550': 55, '545': 55, '500': 50, '498': 50, '495': 50, '490': 50,
      '438': 43, '435': 43, '430': 43, '428': 43, '425': 43, '420': 43,
      '418': 43, '415': 43, '398': 43, '395': 43, '390': 43,
      '348': 32, '345': 32, '340': 32, '328': 32, '325': 32, '320': 32,
      '318': 32, '315': 32,
      '278': 27, '275': 27, '270': 27,
      '248': 24, '245': 24, '240': 24, '238': 24, '235': 24, '230': 24
    };

    function getDiagonal(serial) {
      if (!serial || serial.length < 6) return null;
      const match = serial.toUpperCase().match(/^[A-Z]{3}(\d{3})/);
      if (!match) return null;
      return diagonalMap[match[1]] || null;
    }

    async function getData(sheetName) {
      try {
        const response = await fetch(`${sheetURL}${encodeURIComponent(sheetName)}?key=${apiKey}`);
        const data = await response.json();
        return data.values || [];
      } catch (err) {
        console.error('Ошибка получения данных:', err);
        return [];
      }
    }

    async function fetchData() {
      const sheetNames = ['FI Station KOVALCHYK Y.', 'FI Station 2 ULANOVYCH.R'];
      let combined = [];

      for (const name of sheetNames) {
        const sheetData = await getData(name);
        if (sheetData.length < 2) continue;
        const rows = sheetData.slice(1);
        const mapped = rows.map(row => ({
          date: row[0] || '',
          serial: row[2] || '',
          status: row[4] || '',
          person: row[5] || ''
        }));
        combined = combined.concat(mapped);
      }
      return combined;
    }

    function calculateDetailedStats(data) {
      // Структура: stats[person][diagonal] = { sum, days: Set }
      const stats = {};
      data.forEach(({ date, serial, status, person }) => {
        const diagonal = getDiagonal(serial);
        if (!diagonal) return;

        if (!stats[person]) stats[person] = {};
        if (!stats[person][diagonal]) stats[person][diagonal] = { sum: 0, days: new Set() };

        stats[person][diagonal].sum++;
        const day = date.split(' ')[0];
        if (day) stats[person][diagonal].days.add(day);
      });
      return stats;
    }

    function renderTable(stats) {
      const container = document.getElementById('stats-container');
      container.innerHTML = '';

      const diagonals = Array.from(new Set(
        Object.values(stats).flatMap(p => Object.keys(p).map(Number))
      )).sort((a, b) => b - a);

      const people = Object.keys(stats).sort();
      if (people.length === 0) {
        container.innerHTML = '<p style="text-align:center; margin-top:20px;">Нет данных для выбранного месяца</p>';
        return;
      }

      let percentPerMonthMode = false; // false - режим среднего, true - режим %
      let totalModePercent = false;    // false - сумма, true - %

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');

      // Названия колонок
      const thName = document.createElement('th');
      thName.textContent = 'Name';
      headerRow.appendChild(thName);

      diagonals.forEach(d => {
        const th = document.createElement('th');
        th.textContent = d;
        headerRow.appendChild(th);
      });

      // Кнопка % per month (переключатель)
      const thPercent = document.createElement('th');
      const btnPercent = document.createElement('button');
      btnPercent.textContent = '% per month';
      btnPercent.className = 'toggle-btn';
      thPercent.appendChild(btnPercent);
      headerRow.appendChild(thPercent);

      // Колонка Day
      const thDay = document.createElement('th');
      thDay.textContent = 'Day';
      headerRow.appendChild(thDay);

      // Кнопка Total (переключатель)
      const thTotal = document.createElement('th');
      thTotal.className = 'total-col';
      const btnTotal = document.createElement('button');
      btnTotal.textContent = 'Total';
      btnTotal.className = 'toggle-btn';
      thTotal.appendChild(btnTotal);
      headerRow.appendChild(thTotal);

      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');

      // Считаем общую сумму всех диагоналей всех сотрудников
      let globalTotal = 0;
      const totalPerDiagonal = {};
      diagonals.forEach(d => totalPerDiagonal[d] = 0);

      // Считаем сумму по каждому сотруднику
      const personTotals = {};
      // Для режима % per month - сумма диагоналей по каждому человеку (для деления)
      const personDaysCount = {};

      people.forEach(person => {
        let total = 0;
        let daysSet = new Set();

        // Подсчет общей суммы и уникальных дней
        diagonals.forEach(d => {
          if (stats[person][d]) {
            total += stats[person][d].sum;
            stats[person][d].days.forEach(day => daysSet.add(day));
          }
        });
        personTotals[person] = total;
        personDaysCount[person] = daysSet.size;
        globalTotal += total;

        // Записываем по диагоналям общие итоги
        diagonals.forEach(d => {
          if (stats[person][d]) {
            totalPerDiagonal[d] += stats[person][d].sum;
          }
        });
      });

      // Функция для отрисовки tbody в зависимости от режимов
      function drawBody() {
        tbody.innerHTML = '';
        people.forEach(person => {
          const tr = document.createElement('tr');
          const tdName = document.createElement('td');
          tdName.textContent = person;
          tr.appendChild(tdName);

          // Диагонали
          diagonals.forEach(d => {
            const td = document.createElement('td');
            if (stats[person][d]) {
              if (percentPerMonthMode) {
                // Режим %: показываем процент диагонали от суммы работника
                const percent = personTotals[person] ? (stats[person][d].sum / personTotals[person]) * 100 : 0;
                td.textContent = percent.toFixed(1) + '%';
              } else {
                // Режим среднего количества за день: sum / количество дней
                const daysCount = personDaysCount[person] || 1; // избегаем деления на 0
                const avg = stats[person][d].sum / daysCount;
                td.textContent = avg.toFixed(2);
              }
            } else {
              td.textContent = '-';
            }
            tr.appendChild(td);
          });

          // % per month / average переключатель (число или %)
          const tdPercent = document.createElement('td');
          if (percentPerMonthMode) {
            // В этом столбце пусто, так как проценты по диагоналям уже показаны
            td.textContent = '';
          } else {
            // Показываем среднее арифметическое по всем диагоналям (total / days)
            const daysCount = personDaysCount[person] || 1;
            const avgTotal = personTotals[person] / daysCount;
            td.textContent = avgTotal.toFixed(2);
          }
          tr.appendChild(tdPercent);

          // Колонка Day - количество уникальных дней работы
          const tdDay = document.createElement('td');
          tdDay.textContent = personDaysCount[person];
          tr.appendChild(tdDay);

          // Колонка Total (сумма или % от общей суммы)
          const tdTotal = document.createElement('td');
          if (totalModePercent) {
            const percentTotal = globalTotal ? (personTotals[person] / globalTotal) * 100 : 0;
            tdTotal.textContent = percentTotal.toFixed(1) + '%';
          } else {
            tdTotal.textContent = personTotals[person];
          }
          tdTotal.classList.add('total-col');
          tr.appendChild(tdTotal);

          tbody.appendChild(tr);
        });
      }

      drawBody();
      table.appendChild(tbody);

      // Футер с общими итогами
      const tfoot = document.createElement('tfoot');
      const footerRow = document.createElement('tr');

      const tdLabel = document.createElement('td');
      tdLabel.textContent = 'Total Repaired';
      footerRow.appendChild(tdLabel);

      diagonals.forEach(d => {
        const td = document.createElement('td');
        td.textContent = totalPerDiagonal[d];
        td.classList.add('total-col');
        footerRow.appendChild(td);
      });

      // Пустая ячейка под % per month
      const tdEmptyPercent = document.createElement('td');
      tdEmptyPercent.textContent = '';
      footerRow.appendChild(tdEmptyPercent);

      // Пустая ячейка под Day
      const tdEmptyDay = document.createElement('td');
      tdEmptyDay.textContent = '';
      footerRow.appendChild(tdEmptyDay);

      // Общая сумма по всем
      const tdTotalAll = document.createElement('td');
      tdTotalAll.textContent = globalTotal;
      tdTotalAll.classList.add('total-col');
      footerRow.appendChild(tdTotalAll);

      tfoot.appendChild(footerRow);
      table.appendChild(tfoot);

      container.appendChild(table);

      // Обработчик кнопки % per month
      btnPercent.addEventListener('click', () => {
        percentPerMonthMode = !percentPerMonthMode;
        drawBody();
      });

      // Обработчик кнопки Total
      btnTotal.addEventListener('click', () => {
        totalModePercent = !totalModePercent;
        drawBody();
      });
    }

    function populateMonthSelect(months) {
      const select = document.getElementById('month-select');
      select.innerHTML = '';
      months.forEach(month => {
        const option = document.createElement('option');
        option.value = month;
        option.textContent = month;
        select.appendChild(option);
      });
    }

    function filterDataByMonth(data, month) {
      return data.filter(({ date }) => date.includes(month));
    }

    async function main() {
      const allData = await fetchData();

      // Получаем список уникальных месяцев из дат
      const monthsSet = new Set();
      allData.forEach(({ date }) => {
        if (!date) return;
        const m = date.slice(0, 7); // Формат "YYYY-MM"
        monthsSet.add(m);
      });
      const months = Array.from(monthsSet).sort();

      populateMonthSelect(months);

      function updateTable() {
        const selectedMonth = document.getElementById('month-select').value;
        const filtered = filterDataByMonth(allData, selectedMonth);
        const stats = calculateDetailedStats(filtered);
        renderTable(stats);
      }

      document.getElementById('month-select').addEventListener('change', updateTable);

      if (months.length > 0) {
        document.getElementById('month-select').value = months[months.length - 1];
        updateTable();
      } else {
        document.getElementById('stats-container').innerHTML = '<p style="text-align:center; margin-top:20px;">Нет данных</p>';
      }
    }

    main();
  </script>
</body>
</html>
